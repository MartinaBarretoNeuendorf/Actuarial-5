---
title: "R Notebook"
output: html_notebook
---

MOVIMIENTO BROWNIANO - una sola simulacion de posibles caminos
```{r}
library(tidyverse)

Z0 = 10 #valor inicial
dt = 1/365 #step 
eps = rnorm(1000) #simular 1 valor dist normal
Z1 = Z0 + eps*sqrt(dt)

mean(Z1)
sd(Z1)
sqrt(dt)

#ARMAS EL DATA FRAME DE Z 
Z = tibble(Z = c(Z0,rep(NA,364)))

#LO VAS LLENANDO CON 
for(i in 2:365){
  Z[i,1] = Z[i-1,1] + rnorm(1)*sqrt(dt)
}



df = tibble(t = 1:365, Z=Z$Z)
ggplot(df, aes(x = t, y = Z)) + 
  geom_line()

```
Puedo generar 10.000 caminos de Z 

```{r}

Z0 = 10 #valor inicial
dt = 1/365 #step 
n = 10000 


Z = matrix(NA, ncol = 365, nrow = n)
Z[,1] = Z0 #el arranue de las simulaciones es en z0


#LO VAS LLENANDO CON 
for(i in 1:n){
  for(t in 2:365){
    Z[i,t] = Z[i,t-1] + rnorm(1)*sqrt(dt)
  }
}  

#GRAFICO

  #grafica el primer camino
plot(1:365, Z[1,], type= "l", ylim=c(min(Z),max(Z)),ylab= "Z", xlab="dia")

  #grafica los caminos restantes al grafico de una linea
for(i in 2:n){
  lines(1:365,Z[i,], col = trunc(runif(1)*n)) #lines agrega al grafico eistente
}

mean(Z[,365]);mean #10 - aproximadaente el valor inicial
sd(Z[,365]);sd  #1 - aprox 1: por ser ano el plaxo que estoy considerando, xq c/ timestep es 1/365, si sumo 365 veces ese valor (horizonte total de tiempo)
```

MOVIMIENTO BROWNIANO GENERALIZADO
Agregamos tendencia y volatidad al modelo anterior. Busco construir el deltaX en vez del deltaZ

contras: 
1 - admite precios negativos
2 - el crecimiento no depende del precio actual del activo sino que es un parametro fijo, yo pongo que s=10 y asi se queda, no importa si el precio ahora es 20 o 5000, lo cual no tiene sentido porque el crecimiento de los valores suele ser proporcional a la variacion en el precio, uno piensa en termino de tasas de crecimiento y no en valores

```{r}

Z0 = 10 #valor inicial
dt = 1/365 #step 
n = 10000 


X = matrix(NA, ncol = 365, nrow = n)
X[,1] = Z0 #el arranue de las simulaciones es en z0

a = 0.5
b = 0.2

#LO VAS LLENANDO CON 
for(i in 1:n){
  for(t in 2:365){
    X[i,t] = X[i,t-1] + (a*dt + b* rnorm(1)*sqrt(dt))
  }
}    


#GRAFICO

  #grafica el primer camino
plot(1:365, X[1,], type= "l", ylim=c(min(X),max(X)),ylab= "X", xlab="dia")

  #grafica los caminos restantes al grafico de una linea
for(i in 2:n){
  lines(1:365,X[i,], col = trunc(runif(1)*n)) #lines agrega al grafico eistente
}

lines(1:365, colMeans(X), lwd = 5, col = "black") #agregue linea que marca el promedio en c/u de los momentos del tiempo

#hago un listado con los desvios de cada momento de X 
SD = matrix(NA, ncol = 365, nrow=1)
for (t in 2:365){
  SD[1,t] = sd(X[,t])
}

#como un intervalo de confianza de +-2 desvios
lines(1:365, colMeans(X) + 2*SD, lwd = 5, col = "red")
lines(1:365, colMeans(X) - 2*SD, lwd = 5, col = "red")

mean(X[,365]);mean #10 + A = aprox a 10.5
sd(X[,365]);sd  #0.2 de dispersion , aproximadamente B
```
MOVIMIENTO GEOMETRICO BROWNIANO ojo con error

Como la tendecia ahora es en funcion de x, cuanto mas grande el precio mayor al tendencia, ahora vemos que tenemos un movimiento mas eponencial del camino de precios.
Ya la tendencia y los intervalos de confianza ya no son rectos sino con tendencia exponenecial 
Ahora la media de X ya no es el 50% del valor inicial (15), sino que es mayor porque la tasa del 50% es como que se va capitalizando de manera compuesta con le tiempo

```{r}


dt = 1/365 #step 
n = 10000 


X = matrix(NA, ncol = 365, nrow = n)
X[,1] = 10 #el arranue de las simulaciones es en z0

mu = 0.5 #AHORA SON %
sigma = 0.2

#LO VAS LLENANDO CON 
for(i in 1:n){
  for(t in 2:365){
    X[i,t] = X[i,t-1] + (mu* X[i,t-1] *dt + sigma *X[i,t-1]* rnorm(1)*sqrt(dt))
  }
}    

#GRAFICO

  #grafica el primer camino
plot(1:365, X[1,], type= "l", ylim=c(min(X),max(X)),ylab= paste0("X (mu =",mu,";sigma =",sigma,")"), xlab="dia")

  #grafica los caminos restantes al grafico de una linea
for(i in 2:n){
  lines(1:365,X[i,], col = trunc(runif(1)*n)) #lines agrega al grafico eistente
}

lines(1:365, colMeans(X), lwd = 5, col = "black") #agregue linea que marca el promedio en c/u de los momentos del tiempo

#hago un listado con los desvios de cada momento de X 
SD = matrix(NA, ncol = 365, nrow=1)
for (t in 2:365){
  SD[1,t] = sd(X[,t])
}

#como un intervalo de confianza de +-2 desvios
lines(1:365, colMeans(X) + 2*SD, lwd = 5, col = "red")
lines(1:365, colMeans(X) - 2*SD, lwd = 5, col = "red")

mean(X[,365]);mean #16.4
sd(X[,365]);sd  #3.31 de dispersion 
```
MOVIMIENTO BROWNIANO DE Z OK
```{r}
dt = 1/365 #step 
n = 10000 


S = matrix(NA, ncol = 365, nrow = n)
S[,1] = 10 #el arranue de las simulaciones es en z0
mu = 0.5 #AHORA SON %
sigma = 0.2

#S(t+dt)= St* exp[(mu - 0.5*sigma^2)*dt + epsilon*sigma*raiz(dt)]

#LO VAS LLENANDO CON 
for(i in 1:n){
  for(t in 2:365){
    S[i,t] = S[i,t-1] * exp((mu - 1/2*sigma^2)*dt + rnorm(1)*sigma*sqrt(dt))
  }
}

  #grafica el primer camino
plot(1:365, S[1,], type= "l", ylim=c(min(S),max(S)),ylab= paste0("S (mu =",mu,";sigma =",sigma,")"), xlab="dia")

 #grafica los caminos restantes al grafico de una linea
for(i in 2:n){
  lines(1:365,S[i,], col = trunc(runif(1)*n)) #lines agrega al grafico eistente
}

lines(1:365, colMeans(S), lwd = 5, col = "black") #agregue linea que marca el promedio en c/u de los momentos del tiempo

#hago un listado con los desvios de cada momento de X 
SD = matrix(NA, ncol = 365, nrow=1)
for (t in 2:365){
  SD[1,t] = sd(S[,t])
}

#como un intervalo de confianza de +-2 desvios
lines(1:365, colMeans(S) + 2*SD, lwd = 5, col = "red")
lines(1:365, colMeans(S) - 2*SD, lwd = 5, col = "red")

mean(S[,365]);mean #
sd(S[,365]);sd  #


```


```{r}

s0 = 10
sigma = 0.20
r = 0.05
vto = 0.5
K = 11

d1 = log(s0/K) + (r + 0.5*sigma^2)*vto / (sigma * sqrt(vto))
d2 = d1 - sigma*sqrt(vto)

c = s0 * pnorm(d1) - K * exp(-r*vto) * pnorm(d2)
p = K * exp(-r*vto) * pnorm(-d2) - s0 * pnorm(-d1) 

#cheueamos la pparidad call put
p + s0
c + K*exp(-r*vto)


ST = s0 * exp((r - 1/2*sigma^2)*vto + rnorm(1000000)*sigma*sqrt(vto))
ST

Call_T = sapply(ST, function(x) max (x - K,0))
mean(Call_T)*exp(-r*vto)
```
LETRAS GRIEGAS CLASE

EJERCICIO 1 
```{r}
library(tidyverse)


r = 0.05
K = 50
Vto_0 = 20/52 #20 semanas de 52 totales del ano
#mu = 0.08
sigma = 0.20
cant_S = 100000
So = 49
tipo = "Call"

# costo teorico del call ---------------------------------------------

prima_call = bsm_calculadora(So, K, Vto_0, r, sigma, tipo, q = 0)
costo_teorico_contrato = cant_S*prima_call
cat("el costo del contrato es de ",costo_teorico_contrato)

```
Ahora vamos a hacer la replica de cartera teniendo en cuenta una trayectoria de precios en particular 
```{r}

week = seq(0:20)  
t = seq(0,Vto_0, by=1/52) # el time step va a ser semanal entonces, voy a mirar el valor de S por semana y rebalancear
vto = Vto_0 - t #cuanto falta para el vto segun donde estoy parado
S <- c(49, 48.12, 47.37, 50.25, 51.75, 53.12, 53, 51.87, 51.38, 53, 49.88, 48.5, 49.88, 50.37, 52.13, 51.88, 52.87, 54.87, 54.62, 55.87, 57.25)

d1 = (log(S/K) + (r + 0.5*sigma^2)*vto) / (sigma * sqrt(vto))
delta = pnorm(d1)
position = round(delta,3)*cant_S #posicion que tengo que tener del activo 
Compra_Venta = c(position[1],diff(position))
Costo_S = Compra_Venta*S
Valor_S = position * S

Deuda = rep(NA,21)
Interes = rep(NA,21)
Deuda[1] = Costo_S[1]

for(i in 2:21){
  Interes[i] = Deuda[i-1]*(r*1/52) #aprox porq deberia ser una continua 
  Deuda[i] = Deuda[i-1] + Interes[i] + Costo_S[i]
}

tabla = tibble(week, t, vto, d1, delta, position, Compra_Venta, Costo_S, Deuda, Interes, Valor_S)

Call_entrega = ifelse(S[21]>K, K*cant_S, 0)
Liquido_Deuda = - Deuda[21]
Flujo_Final = Call_entrega + Liquido_Deuda
VP_Costo = Flujo_Final*exp(-r*Vto_0)

#comparo el costo teorico con el costo que me dio la operacion

Resultado = VP_Costo + costo_teorico_contrato
```

LETRAS GRIEGAS 
EJERCICIO 2 - mismo que el anterior, otra trayectoria de precios donde S<K

```{r}

r = 0.05
K = 50
Vto_0 = 20/52 #20 semanas de 52 totales del ano
#mu = 0.08
sigma = 0.20
cant_S = 100000
So = 49
tipo = "Call"

# costo teorico del call ---------------------------------------------

prima_call = bsm_calculadora(So, K, Vto_0, r, sigma, tipo, q = 0)
costo_teorico_contrato = cant_S*prima_call

# Calculo los deltas necesarios
week = seq(0:20)  
t = seq(0,Vto_0, by=1/52) # el time step va a ser semanal entonces, voy a mirar el valor de S por semana y rebalancear
vto = Vto_0 - t #cuanto falta para el vto segun donde estoy parado
S <- c(49.00, 49.75, 52.00, 50.00, 48.38, 48.25, 48.75, 49.63, 48.25, 48.25, 51.12, 51.50, 49.88, 49.88, 48.75, 47.50, 48.00, 46.25, 48.13, 46.63, 48.12)


d1 = (log(S/K) + (r + 0.5*sigma^2)*vto) / (sigma * sqrt(vto))
delta = pnorm(d1)
position = round(delta,3)*cant_S #posicion que tengo que tener del activo 
Compra_Venta = c(position[1],diff(position))
Costo_S = Compra_Venta*S
Valor_S = position * S

Deuda = rep(NA,21)
Interes = rep(NA,21)
Deuda[1] = Costo_S[1]

for(i in 2:21){
  Interes[i] = Deuda[i-1]*(r*1/52) #aprox porq deberia ser una continua 
  Deuda[i] = Deuda[i-1] + Interes[i] + Costo_S[i]
}

tabla = tibble(week, t, vto, d1, delta, position, Compra_Venta, Costo_S, Deuda, Interes, Valor_S)

Call_entrega = ifelse(S[21]>K, K*cant_S, 0)
Liquido_Deuda = - Deuda[21]
Flujo_Final = Call_entrega + Liquido_Deuda
VP_Costo = Flujo_Final*exp(-r*Vto_0)

#comparo el costo teorico con el costo que me dio la operacion

Resultado = VP_Costo + costo_teorico_contrato
```

Ejercicio 3 - Simulo yo los precios y voy rebalanceando cartera, visto desde 0

```{r}
#Parametros
  r = 0.05
  K = 50
  Vto_0 = 20/52 
  mu = 0.08
  sigma = 0.20
  cant_S = 100000
  So = 49
  tipo = "Call"
  week = seq(0:20)  
  dt = 1/52
  t = seq(0,Vto_0, by=dt)
  vto = Vto_0 - t 
  
  drift = (mu - 0.5*sigma^2) * dt
  volatility = sigma * sqrt(dt)
  
#Precios simulados
  S = rep(NA,21)
  
  S[1] = So
  for(i in 2:21){
    S[i] = S[i-1] * exp(drift + volatility * rnorm(1))
  }
  
  
  
S <- c(49.00, 49.75, 52.00, 50.00, 48.38, 48.25, 48.75, 49.63, 48.25, 48.25, 51.12, 51.50, 49.88, 49.88, 48.75, 47.50, 48.00, 46.25, 48.13, 46.63, 48.12)

```






